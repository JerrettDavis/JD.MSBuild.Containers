<Project>

  <!--
    Determine the correct task assembly path based on MSBuild runtime and version.
  -->
  <PropertyGroup>
    <!-- For .NET Core MSBuild, select task assembly based on MSBuild version -->
    <_DockerTasksFolder Condition="'$(MSBuildRuntimeType)' == 'Core' and $([MSBuild]::VersionGreaterThanOrEquals('$(MSBuildVersion)', '18.0'))">net10.0</_DockerTasksFolder>
    <_DockerTasksFolder Condition="'$(_DockerTasksFolder)' == '' and '$(MSBuildRuntimeType)' == 'Core' and $([MSBuild]::VersionGreaterThanOrEquals('$(MSBuildVersion)', '17.14'))">net10.0</_DockerTasksFolder>
    <_DockerTasksFolder Condition="'$(_DockerTasksFolder)' == '' and '$(MSBuildRuntimeType)' == 'Core' and $([MSBuild]::VersionGreaterThanOrEquals('$(MSBuildVersion)', '17.12'))">net9.0</_DockerTasksFolder>
    <_DockerTasksFolder Condition="'$(_DockerTasksFolder)' == '' and '$(MSBuildRuntimeType)' == 'Core'">net8.0</_DockerTasksFolder>

    <!-- Primary path: NuGet package location -->
    <_DockerTaskAssembly>$(MSBuildThisFileDirectory)..\tasks\$(_DockerTasksFolder)\JD.MSBuild.Containers.Tasks.dll</_DockerTaskAssembly>

    <!-- Fallback path: Local development (when building from source) -->
    <_DockerTaskAssembly Condition="!Exists('$(_DockerTaskAssembly)')">$(MSBuildThisFileDirectory)..\..\JD.MSBuild.Containers.Tasks\bin\$(Configuration)\$(_DockerTasksFolder)\JD.MSBuild.Containers.Tasks.dll</_DockerTaskAssembly>
    <_DockerTaskAssembly Condition="!Exists('$(_DockerTaskAssembly)') and '$(Configuration)' == ''">$(MSBuildThisFileDirectory)..\..\JD.MSBuild.Containers.Tasks\bin\Debug\$(_DockerTasksFolder)\JD.MSBuild.Containers.Tasks.dll</_DockerTaskAssembly>
  </PropertyGroup>

  <!--
    Register MSBuild tasks.
  -->
  <UsingTask TaskName="JD.MSBuild.Containers.Tasks.ResolveDockerInputs"
             AssemblyFile="$(_DockerTaskAssembly)" />

  <UsingTask TaskName="JD.MSBuild.Containers.Tasks.GenerateDockerfile"
             AssemblyFile="$(_DockerTaskAssembly)" />

  <UsingTask TaskName="JD.MSBuild.Containers.Tasks.ComputeDockerFingerprint"
             AssemblyFile="$(_DockerTaskAssembly)" />

  <UsingTask TaskName="JD.MSBuild.Containers.Tasks.ExecuteDockerBuild"
             AssemblyFile="$(_DockerTaskAssembly)" />

  <UsingTask TaskName="JD.MSBuild.Containers.Tasks.ExecuteDockerRun"
             AssemblyFile="$(_DockerTaskAssembly)" />

  <UsingTask TaskName="JD.MSBuild.Containers.Tasks.ExecuteDockerScript"
             AssemblyFile="$(_DockerTaskAssembly)" />

  <!--
    ========================================================================
    Docker Build Pipeline: Generate Dockerfile and build container image
    ========================================================================
    
    This pipeline supports multiple configuration modes:
    1. Generate-only: DockerGenerateDockerfile=true, DockerBuildImage=false
    2. Build-only: DockerGenerateDockerfile=false, DockerBuildImage=true (uses existing Dockerfile)
    3. Full automation: DockerGenerateDockerfile=true, DockerBuildImage=true
    4. Custom hooks: Enable specific pre/post scripts independently
  -->

  <!-- Lifecycle hook: BeforeDockerGeneration -->
  <Target Name="BeforeDockerGeneration"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerGenerateDockerfile)' == 'true'" />

  <!-- Resolve Docker inputs and project information -->
  <Target Name="DockerResolveInputs"
          DependsOnTargets="BeforeDockerGeneration"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerGenerateDockerfile)' == 'true'">
    <ResolveDockerInputs
        ProjectPath="$(MSBuildProjectFullPath)"
        AssemblyName="$(AssemblyName)"
        TargetFramework="$(TargetFramework)"
        OutputType="$(OutputType)"
        RuntimeIdentifier="$(RuntimeIdentifier)"
        OutputPath="$(OutputPath)"
        PackageReferences="@(PackageReference)"
        IsWebApplication="$([System.Convert]::ToBoolean('$(UsingMicrosoftNETSdkWeb)'))">
      <Output TaskParameter="ProjectType" PropertyName="_DockerResolvedProjectType" />
      <Output TaskParameter="BaseImage" PropertyName="_DockerResolvedBaseImageRuntime" />
      <Output TaskParameter="SdkImage" PropertyName="_DockerResolvedBaseImageSdk" />
      <Output TaskParameter="EntryPoint" PropertyName="_DockerResolvedEntrypoint" />
      <Output TaskParameter="WorkingDirectory" PropertyName="_DockerResolvedWorkDir" />
      <Output TaskParameter="ExposedPorts" PropertyName="_DockerResolvedExposePort" />
    </ResolveDockerInputs>
  </Target>

  <!-- Compute fingerprint for incremental builds (only if fingerprinting is enabled) -->
  <Target Name="DockerComputeFingerprint"
          DependsOnTargets="DockerResolveInputs"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerGenerateDockerfile)' == 'true' and '$(DockerUseFingerprinting)' == 'true'">
    <MakeDir Directories="$(DockerOutput)" />
    <ComputeDockerFingerprint
        ProjectPath="$(MSBuildProjectFullPath)"
        Configuration="$(Configuration)"
        TargetFramework="$(TargetFramework)"
        DockerBaseImageRuntime="$(_DockerResolvedBaseImageRuntime)"
        DockerBaseImageSdk="$(_DockerResolvedBaseImageSdk)"
        DockerEntrypoint="$(_DockerResolvedEntrypoint)"
        DockerCmd="$(_DockerResolvedCmd)"
        DockerBuildArgs="$(DockerBuildArgs)"
        DockerTemplateFile="$(DockerTemplateFile)"
        FingerprintFile="$(DockerFingerprintFile)"
        LogVerbosity="$(DockerLogVerbosity)">
      <Output TaskParameter="Fingerprint" PropertyName="_DockerFingerprint" />
      <Output TaskParameter="HasChanged" PropertyName="_DockerFingerprintChanged" />
    </ComputeDockerFingerprint>
  </Target>

  <!-- Generate Dockerfile (respects fingerprinting when enabled) -->
  <Target Name="DockerGenerateDockerfile"
          DependsOnTargets="DockerComputeFingerprint"
          BeforeTargets="CoreCompile"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(DockerStampFile)"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerGenerateDockerfile)' == 'true' and '$(DockerGenerateOnBuild)' == 'true' and ('$(DockerUseFingerprinting)' != 'true' or '$(_DockerFingerprintChanged)' == 'true' or !Exists('$(DockerStampFile)'))">
    <GenerateDockerfile
        ProjectPath="$(MSBuildProjectFullPath)"
        ProjectDirectory="$(MSBuildProjectDirectory)"
        AssemblyName="$(AssemblyName)"
        TargetFramework="$(TargetFramework)"
        ProjectType="$(_DockerResolvedProjectType)"
        BaseImageRuntime="$(_DockerResolvedBaseImageRuntime)"
        BaseImageSdk="$(_DockerResolvedBaseImageSdk)"
        WorkDir="$(DockerWorkDir)"
        ExposePort="$(_DockerResolvedExposePort)"
        Entrypoint="$(_DockerResolvedEntrypoint)"
        Cmd="$(_DockerResolvedCmd)"
        UseMultiStage="$(DockerUseMultiStage)"
        RestoreStage="$(DockerRestoreStage)"
        BuildStage="$(DockerBuildStage)"
        PublishStage="$(DockerPublishStage)"
        FinalStage="$(DockerFinalStage)"
        OptimizeLayers="$(DockerOptimizeLayers)"
        CreateUser="$(DockerCreateUser)"
        User="$(DockerUser)"
        NuGetConfigPath="$(DockerNuGetConfigPath)"
        TemplateFile="$(DockerTemplateFile)"
        OutputFile="$(DockerfileOutput)"
        LogVerbosity="$(DockerLogVerbosity)" />
    <WriteLinesToFile File="$(DockerStampFile)" Lines="$(_DockerFingerprint)" Overwrite="true" Condition="'$(DockerUseFingerprinting)' == 'true'" />
    <Message Text="Generated Dockerfile: $(DockerfileOutput)" Importance="high" />
  </Target>

  <!-- Lifecycle hook: AfterDockerGeneration -->
  <Target Name="AfterDockerGeneration"
          AfterTargets="DockerGenerateDockerfile"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerGenerateDockerfile)' == 'true'" />

  <!--
    ========================================================================
    Docker Build Integration with MSBuild Hooks
    ========================================================================
    These targets respect the granular configuration options:
    - DockerExecutePreBuildScript: Controls pre-build script execution
    - DockerBuildOnBuild: Controls whether Docker build runs during MSBuild Build
    - DockerExecutePostBuildScript: Controls post-build script execution
  -->

  <!-- Pre-build script execution (if configured and script exists) -->
  <Target Name="DockerExecutePreBuildScript"
          BeforeTargets="DockerBuild"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerExecutePreBuildScript)' == 'true' and '$(DockerPreBuildScript)' != '' and Exists('$(DockerPreBuildScript)')">
    <ExecuteDockerScript
        ScriptPath="$(DockerPreBuildScript)"
        WorkingDirectory="$(MSBuildProjectDirectory)"
        LogVerbosity="$(DockerLogVerbosity)" />
    <Message Text="Executed pre-build script: $(DockerPreBuildScript)" Importance="high" />
  </Target>

  <!-- Lifecycle hook: BeforeDockerBuild -->
  <Target Name="BeforeDockerBuild"
          DependsOnTargets="DockerExecutePreBuildScript"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerBuildImage)' == 'true' and '$(DockerBuildOnBuild)' == 'true'" />

  <!-- 
    Validate Dockerfile exists for build-only mode.
    When DockerGenerateDockerfile=false and DockerBuildImage=true, we need an existing Dockerfile.
  -->
  <Target Name="DockerValidateExistingDockerfile"
          BeforeTargets="DockerBuild"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerBuildImage)' == 'true' and '$(DockerGenerateDockerfile)' != 'true'">
    <PropertyGroup>
      <_DockerfileToUse Condition="'$(DockerfileSource)' != ''">$(DockerfileSource)</_DockerfileToUse>
      <_DockerfileToUse Condition="'$(_DockerfileToUse)' == ''">$(DockerfileOutput)</_DockerfileToUse>
    </PropertyGroup>
    <Error Condition="!Exists('$(_DockerfileToUse)')"
           Text="Docker build is enabled but no Dockerfile was found at: $(_DockerfileToUse). Either enable DockerGenerateDockerfile=true or provide an existing Dockerfile at DockerfileSource." />
    <Message Text="Using existing Dockerfile for build: $(_DockerfileToUse)" Importance="high" />
  </Target>

  <!-- Docker build execution (runs during Build if DockerBuildOnBuild=true) -->
  <Target Name="DockerBuild"
          DependsOnTargets="BeforeDockerBuild;DockerValidateExistingDockerfile;Build"
          AfterTargets="Build"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerBuildImage)' == 'true' and '$(DockerBuildOnBuild)' == 'true'">
    <PropertyGroup>
      <!-- Use generated Dockerfile if generation is enabled, otherwise use source -->
      <_DockerfilePath Condition="'$(DockerGenerateDockerfile)' == 'true'">$(DockerfileOutput)</_DockerfilePath>
      <_DockerfilePath Condition="'$(_DockerfilePath)' == '' and '$(DockerfileSource)' != ''">$(DockerfileSource)</_DockerfilePath>
      <_DockerfilePath Condition="'$(_DockerfilePath)' == ''">$(DockerfileOutput)</_DockerfilePath>
    </PropertyGroup>
    <ExecuteDockerBuild
        DockerCommand="$(DockerCommand)"
        DockerfilePath="$(_DockerfilePath)"
        BuildContext="$(DockerBuildContext)"
        ImageName="$(DockerImageName)"
        ImageTag="$(DockerImageTag)"
        Registry="$(DockerRegistry)"
        BuildArgs="$(DockerBuildArgs)"
        Platform="$(DockerBuildPlatform)"
        Target="$(DockerBuildTarget)"
        LogVerbosity="$(DockerLogVerbosity)">
      <Output TaskParameter="ImageId" PropertyName="_DockerImageId" />
    </ExecuteDockerBuild>
    <Message Text="Docker image built: $(DockerImageName):$(DockerImageTag) (ID: $(_DockerImageId))" Importance="high" />
  </Target>

  <!-- Post-build script execution (if configured and script exists) -->
  <Target Name="DockerExecutePostBuildScript"
          AfterTargets="DockerBuild"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerExecutePostBuildScript)' == 'true' and '$(DockerPostBuildScript)' != '' and Exists('$(DockerPostBuildScript)')">
    <ExecuteDockerScript
        ScriptPath="$(DockerPostBuildScript)"
        WorkingDirectory="$(MSBuildProjectDirectory)"
        LogVerbosity="$(DockerLogVerbosity)" />
    <Message Text="Executed post-build script: $(DockerPostBuildScript)" Importance="high" />
  </Target>

  <!-- Lifecycle hook: AfterDockerBuild -->
  <Target Name="AfterDockerBuild"
          AfterTargets="DockerExecutePostBuildScript"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerBuildImage)' == 'true' and '$(DockerBuildOnBuild)' == 'true'" />

  <!--
    ========================================================================
    Docker Run Integration
    ========================================================================
    Runs container after build (opt-in via DockerRunContainer=true and DockerRunOnBuild=true)
  -->

  <!-- Lifecycle hook: BeforeDockerRun -->
  <Target Name="BeforeDockerRun"
          DependsOnTargets="DockerBuild"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerRunContainer)' == 'true' and '$(DockerRunOnBuild)' == 'true' and '$(DockerBuildOnBuild)' == 'true'" />

  <!-- Docker run execution (opt-in) -->
  <Target Name="DockerRun"
          DependsOnTargets="BeforeDockerRun"
          AfterTargets="DockerBuild"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerRunContainer)' == 'true' and '$(DockerRunOnBuild)' == 'true' and '$(DockerBuildOnBuild)' == 'true'">
    <ExecuteDockerRun
        DockerCommand="$(DockerCommand)"
        ImageName="$(DockerImageName)"
        ImageTag="$(DockerImageTag)"
        Registry="$(DockerRegistry)"
        PortMappings="$(DockerPortMappings)"
        EnvironmentVariables="$(DockerEnvironmentVariables)"
        VolumeMappings="$(DockerVolumeMappings)"
        LogVerbosity="$(DockerLogVerbosity)">
      <Output TaskParameter="ContainerId" PropertyName="_DockerContainerId" />
    </ExecuteDockerRun>
    <Message Text="Docker container started: $(_DockerContainerId)" Importance="high" />
  </Target>

  <!-- Lifecycle hook: AfterDockerRun -->
  <Target Name="AfterDockerRun"
          AfterTargets="DockerRun"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerRunContainer)' == 'true' and '$(DockerRunOnBuild)' == 'true' and '$(DockerBuildOnBuild)' == 'true'" />

  <!--
    ========================================================================
    Publish Integration
    ========================================================================
    These targets run during Publish and respect DockerBuildOnPublish setting.
  -->

  <!-- Pre-publish script execution (if configured and script exists) -->
  <Target Name="DockerExecutePrePublishScript"
          BeforeTargets="DockerPublish"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerExecutePrePublishScript)' == 'true' and '$(DockerPrePublishScript)' != '' and Exists('$(DockerPrePublishScript)')">
    <ExecuteDockerScript
        ScriptPath="$(DockerPrePublishScript)"
        WorkingDirectory="$(MSBuildProjectDirectory)"
        LogVerbosity="$(DockerLogVerbosity)" />
    <Message Text="Executed pre-publish script: $(DockerPrePublishScript)" Importance="high" />
  </Target>

  <!-- Validate Dockerfile exists for publish -->
  <Target Name="DockerValidateDockerfileForPublish"
          BeforeTargets="DockerPublish"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerBuildImage)' == 'true' and '$(DockerBuildOnPublish)' == 'true' and '$(DockerGenerateDockerfile)' != 'true'">
    <PropertyGroup>
      <_DockerfileToUse Condition="'$(DockerfileSource)' != ''">$(DockerfileSource)</_DockerfileToUse>
      <_DockerfileToUse Condition="'$(_DockerfileToUse)' == ''">$(DockerfileOutput)</_DockerfileToUse>
    </PropertyGroup>
    <Error Condition="!Exists('$(_DockerfileToUse)')"
           Text="Docker build on publish is enabled but no Dockerfile was found at: $(_DockerfileToUse). Either enable DockerGenerateDockerfile=true or provide an existing Dockerfile at DockerfileSource." />
  </Target>

  <!-- Docker build on publish (respects DockerBuildOnPublish setting) -->
  <Target Name="DockerPublish"
          DependsOnTargets="DockerExecutePrePublishScript;DockerValidateDockerfileForPublish;Publish"
          AfterTargets="Publish"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerBuildImage)' == 'true' and '$(DockerBuildOnPublish)' == 'true'">
    <PropertyGroup>
      <!-- Use generated Dockerfile if generation is enabled, otherwise use source -->
      <_DockerfilePath Condition="'$(DockerGenerateDockerfile)' == 'true'">$(DockerfileOutput)</_DockerfilePath>
      <_DockerfilePath Condition="'$(_DockerfilePath)' == '' and '$(DockerfileSource)' != ''">$(DockerfileSource)</_DockerfilePath>
      <_DockerfilePath Condition="'$(_DockerfilePath)' == ''">$(DockerfileOutput)</_DockerfilePath>
    </PropertyGroup>
    <ExecuteDockerBuild
        DockerCommand="$(DockerCommand)"
        DockerfilePath="$(_DockerfilePath)"
        BuildContext="$(DockerBuildContext)"
        ImageName="$(DockerImageName)"
        ImageTag="$(DockerImageTag)"
        Registry="$(DockerRegistry)"
        BuildArgs="$(DockerBuildArgs)"
        Platform="$(DockerBuildPlatform)"
        Target="$(DockerBuildTarget)"
        LogVerbosity="$(DockerLogVerbosity)">
      <Output TaskParameter="ImageId" PropertyName="_DockerPublishImageId" />
    </ExecuteDockerBuild>
    <Message Text="Docker image published: $(DockerImageName):$(DockerImageTag) (ID: $(_DockerPublishImageId))" Importance="high" />
  </Target>

  <!-- Post-publish script execution (if configured and script exists) -->
  <Target Name="DockerExecutePostPublishScript"
          AfterTargets="DockerPublish"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerExecutePostPublishScript)' == 'true' and '$(DockerPostPublishScript)' != '' and Exists('$(DockerPostPublishScript)')">
    <ExecuteDockerScript
        ScriptPath="$(DockerPostPublishScript)"
        WorkingDirectory="$(MSBuildProjectDirectory)"
        LogVerbosity="$(DockerLogVerbosity)" />
    <Message Text="Executed post-publish script: $(DockerPostPublishScript)" Importance="high" />
  </Target>

  <!-- Push to registry (opt-in via DockerPushImage=true and DockerPushOnPublish=true) -->
  <Target Name="DockerPushImage"
          AfterTargets="DockerPublish"
          Condition="'$(DockerEnabled)' == 'true' and '$(DockerPushImage)' == 'true' and '$(DockerPushOnPublish)' == 'true' and '$(DockerRegistry)' != ''">
    <PropertyGroup>
      <_DockerFullImageName Condition="'$(DockerRegistry)' != ''">$(DockerRegistry)/$(DockerImageName):$(DockerImageTag)</_DockerFullImageName>
      <_DockerFullImageName Condition="'$(DockerRegistry)' == ''">$(DockerImageName):$(DockerImageTag)</_DockerFullImageName>
    </PropertyGroup>
    
    <!-- Push the image -->
    <Exec Command="$(DockerCommand) push $(_DockerFullImageName)"
          WorkingDirectory="$(MSBuildProjectDirectory)"
          ConsoleToMSBuild="true">
      <Output TaskParameter="ConsoleOutput" PropertyName="_DockerPushOutput" />
    </Exec>
    <Message Text="Docker image pushed to registry: $(_DockerFullImageName)" Importance="high" />
  </Target>

  <!--
    ========================================================================
    Clean Integration
    ========================================================================
  -->

  <!-- Clean target: remove Docker output directory and optionally generated Dockerfile -->
  <Target Name="DockerClean"
          AfterTargets="Clean"
          Condition="'$(DockerEnabled)' == 'true'">
    <Message Text="Cleaning Docker output: $(DockerOutput)" Importance="normal" />
    <RemoveDir Directories="$(DockerOutput)" Condition="Exists('$(DockerOutput)')" />
    <!-- Only delete Dockerfile if it was generated (not if using existing Dockerfile) -->
    <Delete Files="$(DockerfileOutput)" Condition="'$(DockerGenerateDockerfile)' == 'true' and Exists('$(DockerfileOutput)')" />
    <Message Text="Cleaned generated Dockerfile: $(DockerfileOutput)" Importance="normal" Condition="'$(DockerGenerateDockerfile)' == 'true' and Exists('$(DockerfileOutput)')" />
  </Target>

</Project>
